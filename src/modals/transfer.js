const { Modal } = require('@eartharoid/dbf');const {	EmbedBuilder,	ActionRowBuilder,	ButtonBuilder,	ButtonStyle,} = require('discord.js');const ExtendedEmbedBuilder = require('../lib/embed');const { isStaff } = require('../lib/users');const { logTicketEvent } = require('../lib/logging');module.exports = class TransferModal extends Modal {	constructor(client, options) {		super(client, {			...options,			id: 'transferTicket',		});	}		async run(id, interaction) {				const client = this.client;		await interaction.deferReply();		const ticket = await client.prisma.ticket.findUnique({			include: {				category: true,				_count: { select: { questionAnswers: true } },				claimedBy: true,				guild: true,			},			where: { id: interaction.channel.id },		});		if (!ticket) {			return await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder()						.setColor('Red')						.setTitle('‚ùå Error')						.setDescription('This command can only be used in a ticket channel.'),				],			});		}		const userInput = interaction.fields.getTextInputValue('userMention').trim();		let targetMember = null;		try {			if (/^\d+$/.test(userInput)) {				try {					targetMember = await interaction.guild.members.fetch(userInput);				} catch (err) {					client.log.verbose(`Not a valid member ID: ${userInput}`);				}			}			if (!targetMember) {				const mentionMatch = userInput.match(/<@!?(\d+)>/);				if (mentionMatch) {					try {						targetMember = await interaction.guild.members.fetch(mentionMatch[1]);					} catch (err) {						client.log.verbose(`Mention didn't resolve to valid member: ${userInput}`);					}				}			}			if (!targetMember) {				const searchName = userInput.startsWith('@') ? userInput.substring(1) : userInput;				const allMembers = await interaction.guild.members.fetch();				targetMember = allMembers.find(member =>					member.user.username.toLowerCase() === searchName.toLowerCase() ||          member.displayName.toLowerCase() === searchName.toLowerCase(),				);				if (!targetMember) {					targetMember = allMembers.find(member =>						member.user.username.toLowerCase().includes(searchName.toLowerCase()) ||            member.displayName.toLowerCase().includes(searchName.toLowerCase()),					);				}			}			if (!targetMember) {				throw new Error('Member not found');			}			const targetUserId = targetMember.id;			const isTargetStaff = await isStaff(interaction.guild, targetUserId);			if (!isTargetStaff) {				return await interaction.editReply({					embeds: [						new ExtendedEmbedBuilder({							iconURL: interaction.guild.iconURL(),							text: ticket.guild.footer,						})							.setColor(ticket.guild.errorColour)							.setTitle('Invalid Staff Member')							.setDescription('The selected user is not a staff member.'),					],				});			}			const previousClaimant = ticket.claimedById;			await client.prisma.ticket.update({				data: { claimedBy: { connect: { id: targetUserId } } },				where: { id: interaction.channel.id },			});			await Promise.all([				interaction.channel.permissionOverwrites.delete(previousClaimant, `Ticket transferred by ${interaction.user.tag}`),				...ticket.category.staffRoles.map(role =>					interaction.channel.permissionOverwrites.edit(role, { 'ViewChannel': false },						`Ticket transferred by ${interaction.user.tag}`),				),				interaction.channel.permissionOverwrites.edit(targetUserId,					{						EmbedLinks: true,						ReadMessageHistory: true,						AttachFiles: true,						ViewChannel: true,						SendMessages: true,					},					`Ticket transferred by ${interaction.user.tag}`,				),			]);			const openingMessage = await interaction.channel.messages.fetch(ticket.openingMessageId);			if (openingMessage && openingMessage.components.length !== 0) {				const components = new ActionRowBuilder();				if (ticket.topic || ticket._count?.questionAnswers !== 0) {					components.addComponents(						new ButtonBuilder()							.setCustomId(JSON.stringify({ action: 'edit' }))							.setStyle(ButtonStyle.Secondary)							.setEmoji('‚úèÔ∏è')							.setLabel('Edit'),					);				}				if (ticket.guild.claimButton && ticket.category.claiming) {					components.addComponents(						new ButtonBuilder()							.setCustomId(JSON.stringify({ action: 'unclaim' }))							.setStyle(ButtonStyle.Secondary)							.setEmoji('üîì')							.setLabel('Unclaim'),					);				}				components.addComponents(					new ButtonBuilder()						.setCustomId(JSON.stringify({ action: 'transfer' }))						.setStyle(ButtonStyle.Secondary)						.setEmoji('üîÑ')						.setLabel('Transfer'),				);				if (ticket.guild.closeButton) {					components.addComponents(						new ButtonBuilder()							.setCustomId(JSON.stringify({ action: 'close' }))							.setStyle(ButtonStyle.Danger)							.setEmoji('üîí')							.setLabel('Close'),					);				}				await openingMessage.edit({ components: [components] });			}			await interaction.editReply({				embeds: [					new EmbedBuilder()						.setColor(ticket.guild.primaryColour)						.setDescription(`Ticket transferred from <@${previousClaimant}> to <@${targetUserId}> by ${interaction.user}.`),				],			});			logTicketEvent(client, {				action: 'update',				diff: {					original: { claimedBy: previousClaimant },					updated: { claimedBy: targetUserId },				},				target: {					id: ticket.id,					name: `<#${ticket.id}>`,				},				userId: interaction.user.id,			});		} catch (error) {			client.log.error('Failed to find member:', userInput, error);			return await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.errorColour)						.setTitle('Invalid User')						.setDescription('Could not find that user. Please provide a valid username or mention (e.g., @staff_member).'),				],			});		}	}};