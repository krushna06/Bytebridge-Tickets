const { reusable } = require('../threads');const hoistedRole = member => member.roles.hoist || member.guild.roles.everyone;module.exports = class TicketArchiver {	constructor(client) {				this.client = client;	}		async saveMessage(ticketId, message, external = false) {		if (process.env.OVERRIDE_ARCHIVE === 'false') return false;		if (!message.member) {			try {				message.member = await message.guild.members.fetch(message.author.id);			} catch {				this.client.log.verbose('Failed to fetch member %s of %s', message.author.id, message.guild.id);			}		}		const channels = new Set(message.mentions.channels.values());		const members = new Set(message.mentions.members.values());		const roles = new Set(message.mentions.roles.values());		const worker = await reusable('crypto');		try {			const userQueries = [];			const roleQueries = [];			const channelQueries = [];			const messageQueries = [];			members.add(message.member);			for (const member of members) {				const role = hoistedRole(member);				if (role) roles.add(role);			}			const delay = ms => new Promise(resolve => setTimeout(resolve, ms));			for (const role of roles) {				if (!role.id || !ticketId) continue;				const existingRole = await this.client.prisma.archivedRole.findUnique({					where: {						ticketId_roleId: {							roleId: role.id,							ticketId,						},					},				});				if (!existingRole) {					const data = {						colour: role.hexColor.slice(1),						name: role.name,					};					roleQueries.push(						this.client.prisma.archivedRole.upsert({							create: {								...data,								roleId: role.id,								ticketId,							},							select: { ticketId: true },							update: data,							where: {								ticketId_roleId: {									roleId: role.id,									ticketId,								},							},						}),					);					await delay(100);				}			}			for (const member of members) {				const existingUser = await this.client.prisma.archivedUser.findUnique({					where: {						ticketId_userId: {							ticketId,							userId: member.user.id,						},					},				});				if (!existingUser) {					const data = {						avatar: member.avatar || member.user.avatar,						bot: member.user.bot,						discriminator: member.user.discriminator,						displayName: member.displayName ? await worker.encrypt(member.displayName) : null,						roleId: !!member && hoistedRole(member).id,						username: await worker.encrypt(member.user.username),					};					userQueries.push(						this.client.prisma.archivedUser.upsert({							create: {								...data,								ticketId,								userId: member.user.id,							},							select: { ticketId: true },							update: data,							where: {								ticketId_userId: {									ticketId,									userId: member.user.id,								},							},						}),					);					await delay(100);				}			}			for (const channel of channels) {				const data = {					channelId: channel.id,					name: channel.name,					ticketId,				};				channelQueries.push(					this.client.prisma.archivedChannel.upsert({						create: data,						select: { ticketId: true },						update: data,						where: {							ticketId_channelId: {								channelId: channel.id,								ticketId,							},						},					}),				);				await delay(100);			}			const data = {				content: await worker.encrypt(					JSON.stringify({						attachments: [...message.attachments.values()],						components: [...message.components.values()],						content: message.content,						embeds: message.embeds.map(embed => ({ ...embed })),						reference: message.reference?.messageId ?? null,					}),				),				createdAt: message.createdAt,				edited: !!message.editedAt,				external,			};			messageQueries.push(				this.client.prisma.archivedMessage.upsert({					create: {						...data,						authorId: message.author?.id || 'default',						id: message.id,						ticketId,					},					select: { ticketId: true },					update: data,					where: { id: message.id },				}),			);			await this.client.prisma.$transaction([...roleQueries, ...userQueries, ...channelQueries]);			return await this.client.prisma.$transaction(messageQueries);		} catch (error) {			if (!error.message.includes('Unique constraint failed')) {				this.client.log.error('An error occurred:', error);			}		} finally {			await worker.terminate();		}	}};