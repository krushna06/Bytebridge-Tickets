const { SlashCommand } = require('@eartharoid/dbf');const {	ApplicationCommandOptionType, ThreadAutoArchiveDuration, MessageFlags, Events,} = require('discord.js');const ExtendedEmbedBuilder = require('../../lib/embed');const { isStaff } = require('../../lib/users');const { logTicketEvent } = require('../../lib/logging');module.exports = class NoteSlashCommand extends SlashCommand {	constructor(client, options) {		const name = 'note';		super(client, {			...options,			description: 'Create a private note thread that only staff can see',			dmPermission: false,			name,			options: [				{					description: 'The initial note content',					name: 'text',					required: true,					type: ApplicationCommandOptionType.String,				},			],		});	}		async run(interaction) {				const client = this.client;			await interaction.deferReply({ flags: MessageFlags.Ephemeral });			const ticket = await client.prisma.ticket.findUnique({			include: { guild: true },			where: { id: interaction.channel.id },		});			const existingThreads = interaction.channel.threads.cache.filter(			thread => thread.name.startsWith('üí¨ Staff Notes') && thread.type === 11,		);		if (!ticket) {			const settings = await client.prisma.guild.findUnique({ where: { id: interaction.guild.id } });			return await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: settings.footer,					})						.setColor(settings.errorColour)						.setTitle('‚ùå This isn\'t a ticket channel')						.setDescription('You can only use this command in tickets.'),				],			});		}			if (!(await isStaff(interaction.guild, interaction.user.id))) {			return await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.errorColour)						.setTitle('‚ùå Access Denied')						.setDescription('Only staff members can create notes.'),				],			});		}		const noteText = interaction.options.getString('text', true);		let thread;			if (existingThreads.size > 0) {			thread = existingThreads.first();					await thread.send({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.primaryColour)						.setDescription(noteText)						.setAuthor({							iconURL: interaction.user.displayAvatarURL(),							name: interaction.member.displayName,						})						.setTimestamp(),				],			});					logTicketEvent(this.client, {				action: 'update',				diff: {					original: {},					updated: { 'Staff Note': noteText },				},				target: {					id: ticket.id,					name: `<#${ticket.id}>`,				},				userId: interaction.user.id,			});					return await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.successColour)						.setTitle('‚úÖ Note Added')						.setDescription(`Added note to the existing staff thread: ${thread}`),				],			});		}		try {					const threadName = `üí¨ Staff Notes - #${ticket.number}`;			thread = await interaction.channel.threads.create({				autoArchiveDuration: ThreadAutoArchiveDuration.OneWeek,				name: threadName,				reason: `Staff note created by ${interaction.user.tag}`,				type: 11,			});					const category = await client.prisma.category.findUnique({				select: { staffRoles: true },				where: { id: ticket.categoryId },			});					const threadMembers = await thread.members.fetch();			for (const [memberId, threadMember] of threadMembers) {				const member = await interaction.guild.members.fetch(memberId).catch(() => null);				if (member && !(await isStaff(interaction.guild, memberId))) {					await thread.members.remove(memberId);				}			}							if (ticket.createdById) {				await thread.members.remove(ticket.createdById);			}					const infoMessage = await thread.send({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.primaryColour)						.setTitle('üìù Staff Notes Thread')						.setDescription(							'This is a private thread for staff notes about this ticket. ' +							'Any messages sent here are only visible to staff members. ' +							'The ticket creator and regular users cannot see this thread.',						)						.setFooter({ text: 'Use this thread to discuss the ticket or share private information' }),				],			});					await infoMessage.pin();					const initialMessage = await thread.send({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.primaryColour)						.setTitle('üìù Staff Note')						.setDescription(noteText)						.setAuthor({							iconURL: interaction.user.displayAvatarURL(),							name: interaction.member.displayName,						})						.setFooter({ text: 'Only staff members can see this thread' })						.setTimestamp(),				],			});					await thread.members.add(interaction.user.id);					await initialMessage.pin();					const systemMessages = await thread.messages.fetch({ limit: 10 });			for (const [, message] of systemMessages) {				if (message.system && message.type === 6) {					await message.delete().catch(() => {});				}			}					await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.successColour)						.setTitle('‚úÖ Note Created')						.setDescription(`Created a private staff notes thread: ${thread}`),				],			});					logTicketEvent(this.client, {				action: 'update',				diff: {					original: {},					updated: {						'Staff Note': noteText,						'Staff Notes': 'Thread created',					},				},				target: {					id: ticket.id,					name: `<#${ticket.id}>`,				},				userId: interaction.user.id,			});							const listenerKey = `staff-notes-${thread.id}`;					const messageListener = async message => {							if (message.channel.id === thread.id &&					!message.system &&					!message.author.bot &&					message.content) {									logTicketEvent(client, {						action: 'update',						diff: {							original: {},							updated: {								'From': message.author.tag,								'Staff Note': message.content,							},						},						target: {							id: ticket.id,							name: `<#${ticket.id}>`,						},						userId: message.author.id,					});				}			};					if (!client.staffNoteListeners) {				client.staffNoteListeners = new Map();			}					if (client.staffNoteListeners.has(listenerKey)) {				client.off(Events.MessageCreate, client.staffNoteListeners.get(listenerKey));			}					client.staffNoteListeners.set(listenerKey, messageListener);			client.on(Events.MessageCreate, messageListener);		} catch (error) {			client.log.error('Error creating notes thread:', error);			return await interaction.editReply({				embeds: [					new ExtendedEmbedBuilder({						iconURL: interaction.guild.iconURL(),						text: ticket.guild.footer,					})						.setColor(ticket.guild.errorColour)						.setTitle('‚ö†Ô∏è Error')						.setDescription('Failed to create the notes thread. Please try again.'),				],			});		}	}};