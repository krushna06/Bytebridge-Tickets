const {	spawn,	Pool,	Worker,} = require('threads');const { Readable } = require('node:stream');const { cpus } = require('node:os');const archiver = require('archiver');const { iconURL } = require('../../../../../lib/misc');const pkg = require('../../../../../../package.json');const poolSize = Math.ceil(cpus().length / 4);const pool = Pool(() => spawn(new Worker('../../../../../lib/workers/export.js')), { size: poolSize });module.exports.get = fastify => ({		handler: async (req, res) => {				const client = req.routeOptions.config.client;		const id = req.params.guild;		const guild = client.guilds.cache.get(id);		const member = await guild.members.fetch(req.user.id);		client.log.info(`${member.user.username} requested an export of "${guild.name}"`);		const archive = archiver('zip', {			comment: JSON.stringify({				exportedAt: new Date().toISOString(),				exportedFromClientId: client.user.id,				originalGuildId: id,				originalGuildName: guild.name,				version: pkg.version,			}),		});		archive.on('warning', err => {			if (err.code === 'ENOENT') client.log.warn(err);			else throw err;		});		archive.on('error', err => {			throw err;		});		const settings = await client.prisma.guild.findUnique({			include: {				categories: { include: { questions: true } },				tags: true,			},			where: { id },		});		delete settings.id;		settings.categories = settings.categories.map(c => {			delete c.guildId;			return c;		});		settings.tags = settings.tags.map(t => {			delete t.guildId;			return t;		});		const ticketsStream = Readable.from(ticketsGenerator());		async function* ticketsGenerator() {			try {				let done = false;				const take = 50;				const findOptions = {					include: {						archivedChannels: true,						archivedMessages: true,						archivedRoles: true,						archivedUsers: true,						feedback: true,						questionAnswers: true,					},					orderBy: { id: 'asc' },					take,					where: { guildId: id },				};				do {					const batch = await client.prisma.ticket.findMany(findOptions);					if (batch.length < take) {						done = true;					} else {						findOptions.skip = 1;						findOptions.cursor = { id: batch[take - 1].id };					}					yield* batch.map(async ticket => (await pool.queue(worker => worker.exportTicket(ticket)) + '\n'));				} while (!done);			} finally {				ticketsStream.push(null);			}		}		const icon = await fetch(iconURL(guild));		archive.append(Readable.from(icon.body), { name: 'icon.png' });		archive.append(JSON.stringify(settings), { name: 'settings.json' });		archive.append(ticketsStream, { name: 'tickets.jsonl' });		archive.finalize();		const cleanGuildName = guild.name.replace(/\W/g, '_').replace(/_+/g, '_');		const fileName = `tickets-${cleanGuildName}-${new Date().toISOString().slice(0, 10)}.zip`;		res			.type('application/zip')			.header('content-disposition', `attachment; filename="${fileName}"`)			.send(archive);	},	onRequest: [fastify.authenticate, fastify.isAdmin],});