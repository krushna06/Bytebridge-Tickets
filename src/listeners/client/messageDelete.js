const { Listener } = require('@eartharoid/dbf');const { AuditLogEvent } = require('discord.js');const { logMessageEvent } = require('../../lib/logging');const { quick } = require('../../lib/threads');module.exports = class extends Listener {	constructor(client, options) {		super(client, {			...options,			emitter: client,			event: 'messageDelete',		});	}		async run(message) {				const client = this.client;		if (!message.guild) return;		const ticket = await client.prisma.ticket.findUnique({			include: { guild: true },			where: { id: message.channel.id },		});		if (!ticket) return;		let content = message.cleanContent;		const logEvent = (await message.guild.fetchAuditLogs({			limit: 1,			type: AuditLogEvent.MessageDelete,		})).entries.first();		if (ticket.guild.archive) {			const existing = await client.prisma.archivedMessage.findUnique({ where: { id: message.id } });			if (!existing) {			} else {			  await client.prisma.archivedMessage.update({					data: { deleted: true },					where: { id: message.id },			  });			  const archived = await client.prisma.archivedMessage.findUnique({ where: { id: message.id } });			  if (archived?.content && !content) {					const string = await quick('crypto', w => w.decrypt(archived.content));					content = JSON.parse(string).content;			  }			}		  }		let {			executor,			target,		} = logEvent ?? {};		executor ||= undefined;		if (target?.id !== message.author?.id) executor = undefined;		if (executor) {			try {				executor = await message.guild.members.fetch(executor.id);			} catch (error) {				client.log.error(error);			}		}		if (message.author.id !== client.user.id && !message.flags.has('Ephemeral')) {			await logMessageEvent(this.client, {				action: 'delete',				diff: {					original: { content },					updated: { content: '' },				},				executor,				target: message,				ticket,			});		}	}};